"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addToFeatureCollection = addToFeatureCollection;
exports.calculateDistance = calculateDistance;
exports.getOrCalculateVisibleRegion = getOrCalculateVisibleRegion;
exports.makeFeature = makeFeature;
exports.makeFeatureCollection = makeFeatureCollection;
exports.makeLatLngBounds = makeLatLngBounds;
exports.makeLineString = makeLineString;
exports.makePoint = makePoint;
exports.pointAlongLine = pointAlongLine;
var _helpers = require("@turf/helpers");
var _distance = _interopRequireDefault(require("@turf/distance"));
var _along = _interopRequireDefault(require("@turf/along"));
var _geoViewport = _interopRequireDefault(require("@mapbox/geo-viewport"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const VECTOR_TILE_SIZE = 512;
function makePoint(coordinates, properties, options) {
  return (0, _helpers.point)(coordinates, properties, options);
}
function makeLineString(coordinates, properties, options) {
  return (0, _helpers.lineString)(coordinates, properties, options);
}
function makeLatLngBounds(northEastCoordinates, southWestCoordinates) {
  return (0, _helpers.featureCollection)([(0, _helpers.point)(northEastCoordinates), (0, _helpers.point)(southWestCoordinates)]);
}
function makeFeature(geometry, properties) {
  return (0, _helpers.feature)(geometry, properties);
}
function makeFeatureCollection() {
  let features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let options = arguments.length > 1 ? arguments[1] : undefined;
  return (0, _helpers.featureCollection)(features, options);
}
function addToFeatureCollection(newFeatureCollection, newFeature) {
  return {
    ...newFeatureCollection,
    features: [...newFeatureCollection.features, newFeature]
  };
}
function calculateDistance(origin, dest, options) {
  return (0, _distance.default)(origin, dest, options);
}
function pointAlongLine(newLineString, distAlong, options) {
  return (0, _along.default)(newLineString, distAlong, options);
}
function getOrCalculateVisibleRegion(coord, zoomLevel, width, height, nativeRegion) {
  const region = {
    ne: [0, 0],
    sw: [0, 0]
  };
  if (!nativeRegion || !Array.isArray(nativeRegion.visibleBounds)) {
    const bounds = _geoViewport.default.bounds(coord, zoomLevel, [width, height], VECTOR_TILE_SIZE);
    region.ne = [bounds[3], bounds[2]];
    region.sw = [bounds[1], bounds[0]];
  } else {
    region.ne = nativeRegion.properties.visibleBounds[0];
    region.sw = nativeRegion.properties.visibleBounds[1];
  }
  return region;
}
//# sourceMappingURL=geoUtils.js.map