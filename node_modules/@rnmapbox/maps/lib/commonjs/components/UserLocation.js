"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalIcon = exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _locationManager = _interopRequireDefault(require("../modules/location/locationManager"));
var _Annotation = _interopRequireDefault(require("./annotations/Annotation"));
var _CircleLayer = _interopRequireDefault(require("./CircleLayer"));
var _HeadingIndicator = _interopRequireDefault(require("./HeadingIndicator"));
var _NativeUserLocation = _interopRequireDefault(require("./NativeUserLocation"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const mapboxBlue = 'rgba(51, 181, 229, 100)';
const layerStyles = {
  normal: {
    pluse: {
      circleRadius: 15,
      circleColor: mapboxBlue,
      circleOpacity: 0.2,
      circlePitchAlignment: 'map'
    },
    background: {
      circleRadius: 9,
      circleColor: '#fff',
      circlePitchAlignment: 'map'
    },
    foreground: {
      circleRadius: 6,
      circleColor: mapboxBlue,
      circlePitchAlignment: 'map'
    }
  }
};
const normalIcon = (showsUserHeadingIndicator, heading) => [/*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationPluseCircle",
  id: "mapboxUserLocationPluseCircle",
  style: layerStyles.normal.pluse
}), /*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationWhiteCircle",
  id: "mapboxUserLocationWhiteCircle",
  style: layerStyles.normal.background
}), /*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationBlueCicle",
  id: "mapboxUserLocationBlueCicle",
  aboveLayerID: "mapboxUserLocationWhiteCircle",
  style: layerStyles.normal.foreground
}), ...(showsUserHeadingIndicator && heading !== null ? [(0, _HeadingIndicator.default)({
  heading
})] : [])];
exports.normalIcon = normalIcon;
class UserLocation extends _react.default.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "_isMounted", null);
    _defineProperty(this, "locationManagerRunning", false);
    this.state = {
      shouldShowUserLocation: false,
      coordinates: null,
      heading: null
    };
    this._onLocationUpdate = this._onLocationUpdate.bind(this);
  }

  // required as #setLocationManager attempts to setState
  // after component unmount

  async componentDidMount() {
    this._isMounted = true;
    _locationManager.default.setMinDisplacement(this.props.minDisplacement);
    await this.setLocationManager({
      running: this.needsLocationManagerRunning()
    });
    if (this.renderMode === UserLocation.RenderMode.Native) {
      return;
    }
  }
  async componentDidUpdate(prevProps) {
    await this.setLocationManager({
      running: this.needsLocationManagerRunning()
    });
    if (this.props.minDisplacement !== prevProps.minDisplacement) {
      _locationManager.default.setMinDisplacement(this.props.minDisplacement);
    }
  }
  async componentWillUnmount() {
    this._isMounted = false;
    await this.setLocationManager({
      running: false
    });
  }

  /**
   * Whether to start or stop listening to the locationManager
   *
   * Notice, that listening will start automatically when
   * either `onUpdate` or `visible` are set
   *
   * @async
   * @param {Object} running - Object with key `running` and `boolean` value
   * @return {Promise<void>}
   */
  async setLocationManager(_ref) {
    let {
      running
    } = _ref;
    if (this.locationManagerRunning !== running) {
      this.locationManagerRunning = running;
      if (running) {
        _locationManager.default.addListener(this._onLocationUpdate);
        const location = await _locationManager.default.getLastKnownLocation();
        this._onLocationUpdate(location);
      } else {
        _locationManager.default.removeListener(this._onLocationUpdate);
      }
    }
  }

  /**
   *
   * If locationManager should be running
   *
   * @return {boolean}
   */
  needsLocationManagerRunning() {
    return !!this.props.onUpdate || this.props.renderMode === UserLocation.RenderMode.Normal && this.props.visible;
  }
  _onLocationUpdate(location) {
    if (!this._isMounted || !location) {
      return;
    }
    let coordinates = null;
    let heading = null;
    if (location && location.coords) {
      const {
        longitude,
        latitude
      } = location.coords;
      ({
        heading
      } = location.coords);
      coordinates = [longitude, latitude];
    }
    this.setState({
      coordinates,
      heading
    });
    if (this.props.onUpdate) {
      this.props.onUpdate(location);
    }
  }
  _renderNative() {
    const {
      androidRenderMode,
      showsUserHeadingIndicator
    } = this.props;
    let props = {
      androidRenderMode,
      iosShowsUserHeadingIndicator: showsUserHeadingIndicator
    };
    return /*#__PURE__*/_react.default.createElement(_NativeUserLocation.default, props);
  }
  render() {
    const {
      heading,
      coordinates
    } = this.state;
    const {
      children,
      visible,
      showsUserHeadingIndicator,
      onPress,
      animated
    } = this.props;
    if (!visible) {
      return null;
    }
    if (this.props.renderMode === UserLocation.RenderMode.Native) {
      return this._renderNative();
    }
    if (!coordinates) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Annotation.default, {
      animated: animated,
      id: "mapboxUserLocation",
      onPress: onPress,
      coordinates: coordinates,
      style: {
        iconRotate: heading
      }
    }, children || normalIcon(showsUserHeadingIndicator, heading));
  }
}
_defineProperty(UserLocation, "propTypes", {
  /**
   * Whether location icon is animated between updates
   */
  animated: _propTypes.default.bool,
  /**
   * Which render mode to use.
   * Can either be `normal` or `native`
   */
  renderMode: _propTypes.default.oneOf(['normal', 'native']),
  /**
   * native/android only render mode
   *
   *  - normal: just a circle
   *  - compass: triangle with heading
   *  - gps: large arrow
   *
   * @platform android
   */
  androidRenderMode: _propTypes.default.oneOf(['normal', 'compass', 'gps']),
  /**
   * Whether location icon is visible
   */
  visible: _propTypes.default.bool,
  /**
   * Callback that is triggered on location icon press
   */
  onPress: _propTypes.default.func,
  /**
   * Callback that is triggered on location update
   */
  onUpdate: _propTypes.default.func,
  /**
   * Show or hide small arrow which indicates direction the device is pointing relative to north.
   */
  showsUserHeadingIndicator: _propTypes.default.bool,
  /**
   * Minimum amount of movement before GPS location is updated in meters
   */
  minDisplacement: _propTypes.default.number,
  /**
   * Custom location icon of type mapbox-gl-native components
   */
  children: _propTypes.default.any
});
_defineProperty(UserLocation, "defaultProps", {
  animated: true,
  visible: true,
  showsUserHeadingIndicator: false,
  minDisplacement: 0,
  renderMode: 'normal'
});
_defineProperty(UserLocation, "RenderMode", {
  Native: 'native',
  Normal: 'normal'
});
var _default = UserLocation;
exports.default = _default;
//# sourceMappingURL=UserLocation.js.map