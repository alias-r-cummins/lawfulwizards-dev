"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NATIVE_MODULE_NAME = exports.ANDROID_TEXTURE_NATIVE_MODULE_NAME = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _reactNative = require("react-native");
var _debounce = require("debounce");
var _geoUtils = require("../utils/geoUtils");
var _utils = require("../utils");
var _filterUtils = require("../utils/filterUtils");
var _Logger = _interopRequireDefault(require("../utils/Logger"));
var _NativeBridgeComponent = _interopRequireDefault(require("./NativeBridgeComponent"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
const MapboxGL = _reactNative.NativeModules.MGLModule;
if (MapboxGL == null) {
  console.error('Native part of Mapbox React Native libraries were not registered properly, double check our native installation guides.');
}
const NATIVE_MODULE_NAME = 'RCTMGLMapView';
exports.NATIVE_MODULE_NAME = NATIVE_MODULE_NAME;
const ANDROID_TEXTURE_NATIVE_MODULE_NAME = 'RCTMGLAndroidTextureMapView';
exports.ANDROID_TEXTURE_NATIVE_MODULE_NAME = ANDROID_TEXTURE_NATIVE_MODULE_NAME;
const styles = _reactNative.StyleSheet.create({
  matchParent: {
    flex: 1
  }
});
const defaultStyleURL = MapboxGL.StyleURL.Street;

/**
 * MapView backed by Mapbox Native GL
 */
class MapView extends (0, _NativeBridgeComponent.default)(_react.default.Component, NATIVE_MODULE_NAME) {
  constructor(props) {
    super(props);
    this.logger = _Logger.default.sharedInstance();
    this.logger.start();
    this.state = {
      isReady: null,
      region: null,
      width: 0,
      height: 0,
      isUserInteraction: false
    };
    this._onPress = this._onPress.bind(this);
    this._onLongPress = this._onLongPress.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onLayout = this._onLayout.bind(this);

    // debounced map change methods
    this._onDebouncedRegionWillChange = (0, _debounce.debounce)(this._onRegionWillChange.bind(this), props.regionWillChangeDebounceTime, true);
    this._onDebouncedRegionDidChange = (0, _debounce.debounce)(this._onRegionDidChange.bind(this), props.regionDidChangeDebounceTime);
  }
  componentDidMount() {
    this._setHandledMapChangedEvents(this.props);
  }
  componentWillUnmount() {
    this._onDebouncedRegionWillChange.clear();
    this._onDebouncedRegionDidChange.clear();
    this.logger.stop();
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    this._setHandledMapChangedEvents(nextProps);
  }
  _setHandledMapChangedEvents(props) {
    if ((0, _utils.isAndroid)() || MapboxGL.MapboxV10) {
      const events = [];
      function addIfHasHandler(name) {
        if (props[`on${name}`] != null) {
          if (MapboxGL.EventTypes[name] == null) {
            console.warn(`rnmapbox maps: ${name} is not supported`);
          } else {
            events.push(MapboxGL.EventTypes[name]);
            return true;
          }
        }
        return false;
      }
      addIfHasHandler('RegionWillChange');
      addIfHasHandler('RegionIsChanging');
      addIfHasHandler('RegionDidChange');
      addIfHasHandler('UserLocationUpdate');
      addIfHasHandler('WillStartLoadingMap');
      addIfHasHandler('DidFinishLoadingMap');
      addIfHasHandler('DidFailLoadingMap');
      addIfHasHandler('WillStartRenderingFrame');
      addIfHasHandler('DidFinishRenderingFrame');
      addIfHasHandler('DidFinishRenderingFrameFully');
      addIfHasHandler('WillStartRenderingMap');
      addIfHasHandler('DidFinishRenderingMap');
      addIfHasHandler('DidFinishRenderingMapFully');
      addIfHasHandler('DidFinishLoadingStyle');
      if (addIfHasHandler('MapIdle')) {
        console.warn('onMapIdle is deprecated and will be removed in next beta - please use onRegionDidChange');
        if (props.onRegionDidChange) {
          console.warn('rnmapbox/maps: only one of MapView.onRegionDidChange or onMapIdle is supported');
        }
      }
      if (addIfHasHandler('CameraChanged')) {
        console.warn('onCameraChanged is deprecated and will be removed in next beta - please use onRegionIsChanging');
        if (props.onRegionIsChanging) {
          console.warn('rnmapbox/maps: only one of MapView.onRegionIsChanging or onCameraChanged is supported');
        }
      }
      if (props.onRegionWillChange) {
        console.warn('onRegionWillChange is deprecated and will be removed in v10 - please use onRegionIsChanging');
      }
      this._runNativeCommand('setHandledMapChangedEvents', this._nativeRef, [events]);
    }
  }

  /**
   * Converts a geographic coordinate to a point in the given view’s coordinate system.
   *
   * @example
   * const pointInView = await this._map.getPointInView([-37.817070, 144.949901]);
   *
   * @param {Array<Number>} coordinate - A point expressed in the map view's coordinate system.
   * @return {Array}
   */
  async getPointInView(coordinate) {
    const res = await this._runNativeCommand('getPointInView', this._nativeRef, [coordinate]);
    return res.pointInView;
  }

  /**
   * Converts a point in the given view’s coordinate system to a geographic coordinate.
   *
   * @example
   * const coordinate = await this._map.getCoordinateFromView([100, 100]);
   *
   * @param {Array<Number>} point - A point expressed in the given view’s coordinate system.
   * @return {Array}
   */
  async getCoordinateFromView(point) {
    const res = await this._runNativeCommand('getCoordinateFromView', this._nativeRef, [point]);
    return res.coordinateFromView;
  }

  /**
   * The coordinate bounds (ne, sw) visible in the user’s viewport.
   *
   * @example
   * const visibleBounds = await this._map.getVisibleBounds();
   *
   * @return {Array}
   */
  async getVisibleBounds() {
    const res = await this._runNativeCommand('getVisibleBounds', this._nativeRef);
    return res.visibleBounds;
  }

  /**
   * Returns an array of rendered map features that intersect with a given point.
   *
   * @example
   * this._map.queryRenderedFeaturesAtPoint([30, 40], ['==', 'type', 'Point'], ['id1', 'id2'])
   *
   * @param  {Array<Number>} coordinate - A point expressed in the map view’s coordinate system.
   * @param  {Array=} filter - A set of strings that correspond to the names of layers defined in the current style. Only the features contained in these layers are included in the returned array.
   * @param  {Array=} layerIDs - A array of layer id's to filter the features by
   * @return {FeatureCollection}
   */
  async queryRenderedFeaturesAtPoint(coordinate) {
    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let layerIDs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    if (!coordinate || coordinate.length < 2) {
      throw new Error('Must pass in valid coordinate[lng, lat]');
    }
    const res = await this._runNativeCommand('queryRenderedFeaturesAtPoint', this._nativeRef, [coordinate, (0, _filterUtils.getFilter)(filter), layerIDs]);
    if ((0, _utils.isAndroid)()) {
      return JSON.parse(res.data);
    }
    return res.data;
  }

  /**
   * Returns an array of rendered map features that intersect with the given rectangle,
   * restricted to the given style layers and filtered by the given predicate. In v10,
   * passing an empty array will query the entire visible bounds of the map.
   *
   * @example
   * this._map.queryRenderedFeaturesInRect([30, 40, 20, 10], ['==', 'type', 'Point'], ['id1', 'id2'])
   *
   * @param  {Array<Number>} bbox - A rectangle expressed in the map view’s coordinate system. For v10, this can be an empty array to query the visible map area.
   * @param  {Array=} filter - A set of strings that correspond to the names of layers defined in the current style. Only the features contained in these layers are included in the returned array.
   * @param  {Array=} layerIDs -  A array of layer id's to filter the features by
   * @return {FeatureCollection}
   */
  async queryRenderedFeaturesInRect(bbox) {
    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let layerIDs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (bbox != null && (bbox.length === 4 || MapboxGL.MapboxV10 && bbox.length === 0)) {
      const res = await this._runNativeCommand('queryRenderedFeaturesInRect', this._nativeRef, [bbox, (0, _filterUtils.getFilter)(filter), layerIDs]);
      if ((0, _utils.isAndroid)()) {
        return JSON.parse(res.data);
      }
      return res.data;
    } else {
      throw new Error('Must pass in a valid bounding box: [top, right, bottom, left]. An empty array [] is also acceptable in v10.');
    }
  }

  /**
   * Map camera will perform updates based on provided config. Deprecated use Camera#setCamera.
   */
  setCamera() {
    console.warn('MapView.setCamera is deprecated - please use Camera#setCamera');
  }

  /**
   * Takes snapshot of map with current tiles and returns a URI to the image
   * @param  {Boolean} writeToDisk If true will create a temp file, otherwise it is in base64
   * @return {String}
   */
  async takeSnap() {
    let writeToDisk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const res = await this._runNativeCommand('takeSnap', this._nativeRef, [writeToDisk]);
    return res.uri;
  }

  /**
   * Returns the current zoom of the map view.
   *
   * @example
   * const zoom = await this._map.getZoom();
   *
   * @return {Number}
   */

  async getZoom() {
    const res = await this._runNativeCommand('getZoom', this._nativeRef);
    return res.zoom;
  }

  /**
   * Returns the map's geographical centerpoint
   *
   * @example
   * const center = await this._map.getCenter();
   *
   * @return {Array<Number>} Coordinates
   */
  async getCenter() {
    const res = await this._runNativeCommand('getCenter', this._nativeRef);
    return res.center;
  }

  /**
   * Queries the currently loaded data for elevation at a geographical location.
   * The elevation is returned in meters relative to mean sea-level.
   * Returns null if terrain is disabled or if terrain data for the location hasn't been loaded yet.
   *
   * @param {Array<Number>} coordinate - the coordinates to query elevation at
   * @return {Number}
   */
  async queryTerrainElevation(coordinate) {
    const res = await this._runNativeCommand('queryTerrainElevation', this._nativeRef, [coordinate]);
    return res.data;
  }

  /**
   * Sets the visibility of all the layers referencing the specified `sourceLayerId` and/or `sourceId`
   *
   * @example
   * await this._map.setSourceVisibility(false, 'composite', 'building')
   *
   * @param {boolean} visible - Visibility of the layers
   * @param {String} sourceId - Identifier of the target source (e.g. 'composite')
   * @param {String=} sourceLayerId - Identifier of the target source-layer (e.g. 'building')
   */
  setSourceVisibility(visible, sourceId) {
    let sourceLayerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    this._runNativeCommand('setSourceVisibility', this._nativeRef, [visible, sourceId, sourceLayerId]);
  }

  /**
   * Show the attribution and telemetry action sheet.
   * If you implement a custom attribution button, you should add this action to the button.
   */
  showAttribution() {
    return this._runNativeCommand('showAttribution', this._nativeRef);
  }
  _createStopConfig() {
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const stopConfig = {
      mode: (0, _utils.isNumber)(config.mode) ? config.mode : MapboxGL.CameraModes.Ease,
      pitch: config.pitch,
      heading: config.heading,
      duration: config.duration || 2000,
      zoom: config.zoom
    };
    if (config.centerCoordinate) {
      stopConfig.centerCoordinate = (0, _utils.toJSONString)((0, _geoUtils.makePoint)(config.centerCoordinate));
    }
    if (config.bounds && config.bounds.ne && config.bounds.sw) {
      const {
        ne,
        sw,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom
      } = config.bounds;
      stopConfig.bounds = (0, _utils.toJSONString)((0, _geoUtils.makeLatLngBounds)(ne, sw));
      stopConfig.boundsPaddingTop = paddingTop || 0;
      stopConfig.boundsPaddingRight = paddingRight || 0;
      stopConfig.boundsPaddingBottom = paddingBottom || 0;
      stopConfig.boundsPaddingLeft = paddingLeft || 0;
    }
    return stopConfig;
  }
  _onPress(e) {
    if ((0, _utils.isFunction)(this.props.onPress)) {
      this.props.onPress(e.nativeEvent.payload);
    }
  }
  _onLongPress(e) {
    if ((0, _utils.isFunction)(this.props.onLongPress)) {
      this.props.onLongPress(e.nativeEvent.payload);
    }
  }
  _onRegionWillChange(payload) {
    if ((0, _utils.isFunction)(this.props.onRegionWillChange)) {
      this.props.onRegionWillChange(payload);
    }
    this.setState({
      isUserInteraction: payload.properties.isUserInteraction,
      isAnimatingFromUserInteraction: payload.properties.isAnimatingFromUserInteraction
    });
  }
  _onRegionDidChange(payload) {
    if ((0, _utils.isFunction)(this.props.onRegionDidChange)) {
      this.props.onRegionDidChange(payload);
    }
    this.setState({
      region: payload
    });
  }
  _onChange(e) {
    const {
      regionWillChangeDebounceTime,
      regionDidChangeDebounceTime
    } = this.props;
    const {
      type,
      payload
    } = e.nativeEvent;
    let propName = '';
    switch (type) {
      case MapboxGL.EventTypes.RegionWillChange:
        if (regionWillChangeDebounceTime > 0) {
          this._onDebouncedRegionWillChange(payload);
        } else {
          propName = 'onRegionWillChange';
        }
        break;
      case MapboxGL.EventTypes.RegionIsChanging:
        propName = 'onRegionIsChanging';
        break;
      case MapboxGL.EventTypes.RegionDidChange:
        if (regionDidChangeDebounceTime > 0) {
          this._onDebouncedRegionDidChange(payload);
        } else {
          propName = 'onRegionDidChange';
        }
        break;
      case MapboxGL.EventTypes.CameraChanged:
        propName = 'onCameraChanged';
        break;
      case MapboxGL.EventTypes.MapIdle:
        propName = 'onMapIdle';
        break;
      case MapboxGL.EventTypes.UserLocationUpdated:
        propName = 'onUserLocationUpdate';
        break;
      case MapboxGL.EventTypes.WillStartLoadingMap:
        propName = 'onWillStartLoadingMap';
        break;
      case MapboxGL.EventTypes.DidFinishLoadingMap:
        propName = 'onDidFinishLoadingMap';
        break;
      case MapboxGL.EventTypes.DidFailLoadingMap:
        propName = 'onDidFailLoadingMap';
        break;
      case MapboxGL.EventTypes.WillStartRenderingFrame:
        propName = 'onWillStartRenderingFrame';
        break;
      case MapboxGL.EventTypes.DidFinishRenderingFrame:
        propName = 'onDidFinishRenderingFrame';
        break;
      case MapboxGL.EventTypes.DidFinishRenderingFrameFully:
        propName = 'onDidFinishRenderingFrameFully';
        break;
      case MapboxGL.EventTypes.WillStartRenderingMap:
        propName = 'onWillStartRenderingMap';
        break;
      case MapboxGL.EventTypes.DidFinishRenderingMap:
        propName = 'onDidFinishRenderingMap';
        break;
      case MapboxGL.EventTypes.DidFinishRenderingMapFully:
        propName = 'onDidFinishRenderingMapFully';
        break;
      case MapboxGL.EventTypes.DidFinishLoadingStyle:
        propName = 'onDidFinishLoadingStyle';
        break;
      default:
        console.warn('Unhandled event callback type', type);
    }
    if (propName.length) {
      this._handleOnChange(propName, payload);
    }
  }
  _onLayout(e) {
    this.setState({
      isReady: true,
      width: e.nativeEvent.layout.width,
      height: e.nativeEvent.layout.height
    });
  }
  _handleOnChange(propName, payload) {
    if ((0, _utils.isFunction)(this.props[propName])) {
      this.props[propName](payload);
    }
  }
  _getCenterCoordinate() {
    if (!this.props.centerCoordinate) {
      return;
    }
    return (0, _utils.toJSONString)((0, _geoUtils.makePoint)(this.props.centerCoordinate));
  }
  _getVisibleCoordinateBounds() {
    if (!this.props.visibleCoordinateBounds) {
      return;
    }
    return (0, _utils.toJSONString)((0, _geoUtils.makeLatLngBounds)(this.props.visibleCoordinateBounds[0], this.props.visibleCoordinateBounds[1]));
  }
  _getContentInset() {
    if (!this.props.contentInset) {
      return;
    }
    if (!Array.isArray(this.props.contentInset)) {
      return [this.props.contentInset];
    }
    return this.props.contentInset;
  }
  _setNativeRef(nativeRef) {
    this._nativeRef = nativeRef;
    super._runPendingNativeCommands(nativeRef);
  }
  setNativeProps(props) {
    if (this._nativeRef) {
      this._nativeRef.setNativeProps(props);
    }
  }
  _setStyleURL(props) {
    // user set a styleURL, no need to alter props
    if (props.styleURL) {
      return;
    }

    // user set styleJSON pass it to styleURL
    if (props.styleJSON && !props.styleURL) {
      props.styleURL = props.styleJSON;
    }

    // user neither set styleJSON nor styleURL
    // set defaultStyleUrl
    if (!props.styleJSON || !props.styleURL) {
      props.styleURL = defaultStyleURL;
    }
  }
  render() {
    const props = {
      ...this.props,
      contentInset: this._getContentInset(),
      style: styles.matchParent
    };
    this._setStyleURL(props);
    const callbacks = {
      ref: nativeRef => this._setNativeRef(nativeRef),
      onPress: this._onPress,
      onLongPress: this._onLongPress,
      onMapChange: this._onChange,
      onAndroidCallback: (0, _utils.isAndroid)() ? this._onAndroidCallback : undefined
    };
    let mapView = null;
    if ((0, _utils.isAndroid)() && !this.props.surfaceView && this.state.isReady) {
      mapView = /*#__PURE__*/_react.default.createElement(RCTMGLAndroidTextureMapView, _extends({}, props, callbacks), this.props.children);
    } else if (this.state.isReady) {
      mapView = /*#__PURE__*/_react.default.createElement(RCTMGLMapView, _extends({}, props, callbacks), this.props.children);
    }
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      onLayout: this._onLayout,
      style: this.props.style,
      testID: mapView ? null : this.props.testID
    }, mapView);
  }
}
_defineProperty(MapView, "propTypes", {
  ..._utils.viewPropTypes,
  /**
   * The distance from the edges of the map view’s frame to the edges of the map view’s logical viewport.
   */
  contentInset: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.number), _propTypes.default.number]),
  /**
   * The projection used when rendering the map
   */
  projection: _propTypes.default.oneOf(['mercator', 'globe']),
  /**
   * Style for wrapping React Native View
   */
  style: _propTypes.default.any,
  /**
   * Style URL for map - notice, if non is set it _will_ default to `MapboxGL.StyleURL.Street`
   */
  styleURL: _propTypes.default.string,
  /**
   * StyleJSON for map - according to TileJSON specs: https://github.com/mapbox/tilejson-spec
   */
  styleJSON: _propTypes.default.string,
  /**
   * iOS: The preferred frame rate at which the map view is rendered.
   * The default value for this property is MGLMapViewPreferredFramesPerSecondDefault,
   * which will adaptively set the preferred frame rate based on the capability of
   * the user’s device to maintain a smooth experience. This property can be set to arbitrary integer values.
   *
   * Android: The maximum frame rate at which the map view is rendered, but it can't exceed the ability of device hardware.
   * This property can be set to arbitrary integer values.
   */
  preferredFramesPerSecond: _propTypes.default.number,
  /**
   * Automatically change the language of the map labels to the system’s preferred language,
   * this is not something that can be toggled on/off
   */
  localizeLabels: _propTypes.default.bool,
  /**
   * Enable/Disable zoom on the map
   */
  zoomEnabled: _propTypes.default.bool,
  /**
   * Enable/Disable scroll on the map
   */
  scrollEnabled: _propTypes.default.bool,
  /**
   * Enable/Disable pitch on map
   */
  pitchEnabled: _propTypes.default.bool,
  /**
   * Enable/Disable rotation on map
   */
  rotateEnabled: _propTypes.default.bool,
  /**
   * The Mapbox terms of service, which governs the use of Mapbox-hosted vector tiles and styles,
   * [requires](https://www.mapbox.com/help/how-attribution-works/) these copyright notices to accompany any map that features Mapbox-designed styles, OpenStreetMap data, or other Mapbox data such as satellite or terrain data.
   * If that applies to this map view, do not hide this view or remove any notices from it.
   *
   * You are additionally [required](https://www.mapbox.com/help/how-mobile-apps-work/#telemetry) to provide users with the option to disable anonymous usage and location sharing (telemetry).
   * If this view is hidden, you must implement this setting elsewhere in your app. See our website for [Android](https://www.mapbox.com/android-docs/map-sdk/overview/#telemetry-opt-out) and [iOS](https://www.mapbox.com/ios-sdk/#telemetry_opt_out) for implementation details.
   *
   * Enable/Disable attribution on map. For iOS you need to add MGLMapboxMetricsEnabledSettingShownInApp=YES
   * to your Info.plist
   */
  attributionEnabled: _propTypes.default.bool,
  /**
   * Adds attribution offset, e.g. `{top: 8, left: 8}` will put attribution button in top-left corner of the map. By default on Android, the attribution with information icon (i) will be on the bottom left, while on iOS the mapbox logo will be on bottom left with information icon (i) on bottom right. Read more about mapbox attribution [here](https://docs.mapbox.com/help/getting-started/attribution/)
   */
  attributionPosition: _utils.ornamentPositionPropType,
  /**
   * MapView's tintColor
   */
  tintColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array]),
  /**
   * Enable/Disable the logo on the map.
   */
  logoEnabled: _propTypes.default.bool,
  /**
   * Adds logo offset, e.g. `{top: 8, left: 8}` will put the logo in top-left corner of the map
   */
  logoPosition: _utils.ornamentPositionPropType,
  /**
   * Enable/Disable the compass from appearing on the map
   */
  compassEnabled: _propTypes.default.bool,
  /**
   * [`mapbox` (v10) implementation only] Enable/Disable if the compass should fade out when the map is pointing north
   */
  compassFadeWhenNorth: _propTypes.default.bool,
  /**
   * [`mapbox` (v10) implementation only] Adds compass offset, e.g. `{top: 8, left: 8}` will put the compass in top-left corner of the map
   */
  compassPosition: _utils.ornamentPositionPropType,
  /**
   * Change corner of map the compass starts at. 0: TopLeft, 1: TopRight, 2: BottomLeft, 3: BottomRight
   */
  compassViewPosition: _propTypes.default.number,
  /**
   * Add margins to the compass with x and y values
   */
  compassViewMargins: _propTypes.default.object,
  /**
   * [iOS, `mapbox` (v10) implementation only] A string referencing an image key. Requires an `Images` component.
   */
  compassImage: _propTypes.default.string,
  /**
   * [`mapbox` (v10) implementation only] Enable/Disable the scale bar from appearing on the map
   */
  scaleBarEnabled: _propTypes.default.bool,
  /**
   * [`mapbox` (v10) implementation only] Adds scale bar offset, e.g. `{top: 8, left: 8}` will put the scale bar in top-left corner of the map
   */
  scaleBarPosition: _utils.ornamentPositionPropType,
  /**
   * [Android only] Enable/Disable use of GLSurfaceView instead of TextureView.
   */
  surfaceView: _propTypes.default.bool,
  /**
   * Map press listener, gets called when a user presses the map
   */
  onPress: _propTypes.default.func,
  /**
   * Map long press listener, gets called when a user long presses the map
   */
  onLongPress: _propTypes.default.func,
  /**
   * <v10 only
   *
   * This event is triggered whenever the currently displayed map region is about to change.
   *
   * @param {PointFeature} feature - The geojson point feature at the camera center, properties contains zoomLevel, visibleBounds
   */
  onRegionWillChange: _propTypes.default.func,
  /**
   *
   * This event is triggered whenever the currently displayed map region is changing.
   *
   * @param {PointFeature} feature - The geojson point feature at the camera center, properties contains zoomLevel, visibleBounds
   */
  onRegionIsChanging: _propTypes.default.func,
  /**
   *
   * This event is triggered whenever the currently displayed map region finished changing.
   *
   * @param {PointFeature} feature - The geojson point feature at the camera center, properties contains zoomLevel, visibleBounds
   */
  onRegionDidChange: _propTypes.default.func,
  /**
   * iOS, v10 only, deprecated will be removed in next version - please use onRegionIsChanging.
   */
  onCameraChanged: _propTypes.default.func,
  /**
   * iOS, v10 only, deprecated will be removed in next version - please use onRegionDidChange
   */
  onMapIdle: _propTypes.default.func,
  /**
   * This event is triggered when the map is about to start loading a new map style.
   */
  onWillStartLoadingMap: _propTypes.default.func,
  /**
   * This is triggered when the map has successfully loaded a new map style.
   */
  onDidFinishLoadingMap: _propTypes.default.func,
  /**
   * This event is triggered when the map has failed to load a new map style.
   */
  onDidFailLoadingMap: _propTypes.default.func,
  /**
   * This event is triggered when the map will start rendering a frame.
   */
  onWillStartRenderingFrame: _propTypes.default.func,
  /**
   * This event is triggered when the map finished rendering a frame.
   */
  onDidFinishRenderingFrame: _propTypes.default.func,
  /**
   * This event is triggered when the map fully finished rendering a frame.
   */
  onDidFinishRenderingFrameFully: _propTypes.default.func,
  /**
   * This event is triggered when the map will start rendering the map.
   */
  onWillStartRenderingMap: _propTypes.default.func,
  /**
   * This event is triggered when the map finished rendering the map.
   */
  onDidFinishRenderingMap: _propTypes.default.func,
  /**
   * This event is triggered when the map fully finished rendering the map.
   */
  onDidFinishRenderingMapFully: _propTypes.default.func,
  /**
   * This event is triggered when the user location is updated.
   */
  onUserLocationUpdate: _propTypes.default.func,
  /**
   * This event is triggered when a style has finished loading.
   */
  onDidFinishLoadingStyle: _propTypes.default.func,
  /**
   * The emitted frequency of regionwillchange events
   */
  regionWillChangeDebounceTime: _propTypes.default.number,
  /**
   * The emitted frequency of regiondidchange events
   */
  regionDidChangeDebounceTime: _propTypes.default.number
});
_defineProperty(MapView, "defaultProps", {
  projection: 'mercator',
  localizeLabels: false,
  scrollEnabled: true,
  pitchEnabled: true,
  rotateEnabled: true,
  attributionEnabled: true,
  compassEnabled: false,
  compassFadeWhenNorth: false,
  logoEnabled: true,
  scaleBarEnabled: true,
  surfaceView: false,
  regionWillChangeDebounceTime: 10,
  regionDidChangeDebounceTime: 500
});
const RCTMGLMapView = (0, _reactNative.requireNativeComponent)(NATIVE_MODULE_NAME, MapView, {
  nativeOnly: {
    onMapChange: true,
    onAndroidCallback: true
  }
});
let RCTMGLAndroidTextureMapView;
if ((0, _utils.isAndroid)()) {
  RCTMGLAndroidTextureMapView = (0, _reactNative.requireNativeComponent)(ANDROID_TEXTURE_NATIVE_MODULE_NAME, MapView, {
    nativeOnly: {
      onMapChange: true,
      onAndroidCallback: true
    }
  });
}
var _default = MapView;
exports.default = _default;
//# sourceMappingURL=MapView.js.map